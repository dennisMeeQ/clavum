generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- Tenants ---

model Tenant {
  id        String   @id @default(uuid())
  name      String
  createdAt DateTime @default(now()) @map("created_at")

  // Per-tenant server X25519 keypair (OD-2)
  x25519Private Bytes @map("server_x25519_priv")
  x25519Public  Bytes @map("server_x25519_pub")

  agents      Agent[]
  phones      Phone[]
  secrets     SecretMetadata[]
  invitations PairingInvitation[]

  @@map("tenants")
}

// --- Pairing Invitations ---

model PairingInvitation {
  id        String   @id @default(uuid())
  tenantId  String   @map("tenant_id")
  token     String   @unique
  type      String   // "agent" or "phone"
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@map("pairing_invitations")
}

// --- Paired Agents ---

model Agent {
  id       String @id @default(uuid())
  tenantId String @map("tenant_id")
  name     String // e.g. "pepe"

  // Agent's public keys (registered at pairing)
  x25519Public  Bytes @map("x25519_pub")
  ed25519Public Bytes @map("ed25519_pub")

  // Key pinning (OD-4a mitigation)
  allowedIps    String[] @map("allowed_ips")
  machineFingerprint String? @map("machine_fingerprint")

  createdAt DateTime @default(now()) @map("created_at")
  lastSeenAt DateTime? @map("last_seen_at")

  tenant  Tenant           @relation(fields: [tenantId], references: [id])
  secrets SecretMetadata[]
  audits  AuditLog[]

  @@map("agents")
}

// --- Paired Phones ---

model Phone {
  id       String @id @default(uuid())
  tenantId String @map("tenant_id")
  name     String // e.g. "Dennis iPhone"

  // Phone's public keys (registered at pairing)
  x25519Public  Bytes @map("x25519_pub")
  ed25519Public Bytes @map("ed25519_pub")

  // Push notification endpoint
  pushEndpoint String? @map("push_endpoint")

  createdAt DateTime @default(now()) @map("created_at")
  lastSeenAt DateTime? @map("last_seen_at")

  tenant    Tenant            @relation(fields: [tenantId], references: [id])
  approvals ApprovalRequest[]

  @@map("phones")
}

// --- Secret Metadata (NOT the encrypted data — that's on agent machine) ---

model SecretMetadata {
  id       String @id @default(uuid())
  tenantId String @map("tenant_id")
  agentId  String @map("agent_id")
  name     String
  tier     Tier

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant Tenant     @relation(fields: [tenantId], references: [id])
  agent  Agent      @relation(fields: [agentId], references: [id])
  audits AuditLog[]

  @@unique([agentId, name])
  @@map("secret_metadata")
}

enum Tier {
  green
  yellow
  red
}

// --- Approval Requests ---

model ApprovalRequest {
  id        String          @id @default(uuid())
  phoneId   String          @map("phone_id")
  secretId  String          @map("secret_id")
  reason    String
  challenge Bytes           // context-bound: random(32) ‖ secret_id ‖ SHA256(reason)
  status    ApprovalStatus  @default(pending)

  // Cryptographic proof of approval
  approvalSig Bytes? @map("approval_sig")

  createdAt   DateTime  @default(now()) @map("created_at")
  respondedAt DateTime? @map("responded_at")
  expiresAt   DateTime  @map("expires_at")

  phone Phone @relation(fields: [phoneId], references: [id])

  @@map("approval_requests")
}

enum ApprovalStatus {
  pending
  approved
  denied
  expired
}

// --- Audit Log ---

model AuditLog {
  id       String @id @default(uuid())
  agentId  String @map("agent_id")
  secretId String @map("secret_id")
  reason   String
  tier     Tier
  result   AuditResult

  // Cryptographic proof (approval_sig for yellow, K_phone participation for red)
  proof Bytes?

  createdAt DateTime @default(now()) @map("created_at")
  latencyMs Int?     @map("latency_ms")

  agent  Agent          @relation(fields: [agentId], references: [id])
  secret SecretMetadata @relation(fields: [secretId], references: [id])

  @@map("audit_log")
}

enum AuditResult {
  auto_granted     // green
  human_approved   // yellow
  device_unlocked  // red
  denied
  expired
  error
}

// --- Nonce Dedup (request signature replay prevention) ---

model UsedNonce {
  id        String   @id @default(uuid())
  nonce     String   @unique
  expiresAt DateTime @map("expires_at")

  @@map("used_nonces")
}
